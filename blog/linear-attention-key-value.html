<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Normalization Matters: Rethinking Key-Value Relationships in Linear Attention | Chunyuan Deng</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>

  <style>
    :root {
      --morandi-cream: #f5f0e8;
      --morandi-warm-white: #faf7f2;
      --morandi-sage: #8a9a7b;
      --morandi-sage-dark: #6b7a5e;
      --morandi-dusty-rose: #c9a8a0;
      --morandi-charcoal: #4a4541;
      --renaissance-forest: #3d4f3a;
      --renaissance-burgundy: #6b3a3a;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: linear-gradient(135deg, var(--morandi-warm-white) 0%, var(--morandi-cream) 50%, #f0ebe3 100%);
      font-family: 'EB Garamond', Georgia, serif;
      color: var(--morandi-charcoal);
      line-height: 1.6;
      padding: 25px 15px;
    }

    .container {
      max-width: 850px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.75);
      padding: 40px 50px;
      border-radius: 3px;
      box-shadow: 0 6px 24px rgba(61, 79, 58, 0.12);
    }

    .header {
      text-align: center;
      margin-bottom: 35px;
      padding-bottom: 18px;
      border-bottom: 2px solid var(--renaissance-forest);
    }

    h1 {
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-size: 34px;
      font-weight: 700;
      color: var(--renaissance-forest);
      margin-bottom: 10px;
      letter-spacing: 0.5px;
      line-height: 1.2;
    }

    .subtitle {
      font-size: 17px;
      color: var(--morandi-sage-dark);
      font-style: italic;
    }

    .meta {
      margin-top: 12px;
      font-size: 13px;
      color: var(--morandi-sage);
    }

    h2 {
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-size: 22px;
      font-weight: 700;
      color: var(--renaissance-forest);
      margin: 30px 0 15px 0;
      letter-spacing: 0.3px;
    }

    h3 {
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-size: 18px;
      font-weight: 600;
      color: var(--morandi-sage-dark);
      margin: 22px 0 10px 0;
    }

    p {
      font-size: 15px;
      margin-bottom: 12px;
      text-align: justify;
    }

    a {
      color: var(--renaissance-forest);
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: all 0.3s ease;
    }

    a:hover {
      color: var(--renaissance-burgundy);
      border-bottom: 1px solid var(--renaissance-burgundy);
    }

    .tldr {
      background: linear-gradient(135deg, rgba(138, 154, 123, 0.08) 0%, rgba(201, 168, 160, 0.08) 100%);
      border-left: 3px solid var(--morandi-sage-dark);
      padding: 16px 20px;
      margin: 25px 0;
      border-radius: 2px;
      font-size: 14px;
      line-height: 1.5;
    }

    .tldr strong {
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-size: 16px;
      color: var(--renaissance-forest);
      letter-spacing: 0.5px;
    }

    .equation-block {
      background: rgba(250, 247, 242, 0.9);
      border: 1px solid var(--morandi-sage);
      padding: 12px;
      margin: 15px 0;
      border-radius: 2px;
      overflow-x: auto;
      font-size: 14px;
    }

    .figure {
      margin: 25px 0;
      text-align: center;
    }

    .figure img {
      max-width: 100%;
      height: auto;
      border-radius: 3px;
      box-shadow: 0 3px 12px rgba(61, 79, 58, 0.15);
    }

    .figure-caption {
      margin-top: 8px;
      font-size: 13px;
      color: var(--morandi-sage);
      font-style: italic;
      line-height: 1.4;
    }

    .insight-box {
      background: rgba(138, 154, 123, 0.12);
      border: 2px solid var(--morandi-sage-dark);
      padding: 18px 22px;
      margin: 22px 0;
      border-radius: 3px;
      font-size: 14px;
    }

    .insight-box h3 {
      color: var(--renaissance-forest);
      margin-top: 0;
      margin-bottom: 10px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 18px 0;
      font-size: 14px;
    }

    th {
      background: var(--renaissance-forest);
      color: var(--morandi-warm-white);
      padding: 8px;
      text-align: left;
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-weight: 600;
      font-size: 13px;
    }

    td {
      padding: 7px 8px;
      border-bottom: 1px solid rgba(138, 154, 123, 0.3);
      font-size: 13px;
    }

    tr:hover {
      background: rgba(138, 154, 123, 0.04);
    }

    ul, ol {
      margin-left: 28px;
      margin-bottom: 12px;
      font-size: 14px;
    }

    li {
      margin-bottom: 5px;
    }

    .back-link {
      margin-top: 40px;
      padding-top: 22px;
      border-top: 2px solid var(--renaissance-forest);
      text-align: center;
    }

    .back-link a {
      font-family: 'Cormorant Garamond', Georgia, serif;
      font-size: 15px;
      font-weight: 600;
      color: var(--renaissance-forest);
      padding: 9px 22px;
      border: 2px solid var(--renaissance-forest);
      border-radius: 2px;
      display: inline-block;
      transition: all 0.3s ease;
    }

    .back-link a:hover {
      background: var(--renaissance-forest);
      color: var(--morandi-warm-white);
      border-bottom: 2px solid var(--renaissance-forest);
    }

    code {
      font-family: 'Courier New', monospace;
      background: rgba(138, 154, 123, 0.1);
      padding: 2px 5px;
      border-radius: 2px;
      font-size: 13px;
    }

    @media (max-width: 768px) {
      .container { padding: 28px 22px; }
      h1 { font-size: 26px; }
      h2 { font-size: 20px; }
      p, ul, ol { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Rethinking Key-Value Relationships in Linear Attention</h1>
      <div class="subtitle">What happens when we test DeltaNet on diverse nonlinear relationships?</div>
      <div class="meta">Chunyuan Deng • February 2026</div>
    </div>

    <div class="tldr">
      <strong>TL;DR</strong><br><br>
      We tested how DeltaNet handles diverse key-value relationships from identity to exponentials, scaling up to 32,000 tokens. Under standard normalized conditions, DeltaNet stays remarkably stable (MSE ~0.030) whether values come from $k^2$ or $e^k$. The surprise came when we removed normalization: polynomial relationships became easier, not harder, due to magnitude shrinkage crushing variance toward zero. Meanwhile vanilla linear attention completely breaks at long contexts (MSE 1306 at 32k tokens) while DeltaNet holds steady. Information theory explains the bounds: DeltaNet retains 99.6% of information for identity but only 1.2% for exponentials, revealing fundamental compression limits.
    </div>

    <h2>I. Background: Linear Attention as Test-Time Regression</h2>

    <p>Linear attention mechanisms maintain a state matrix $S_t \in \mathbb{R}^{d \times d}$ that evolves recurrently. Three update rules represent the evolution of this paradigm:</p>

    <table>
      <tr>
        <th>Model</th>
        <th>Update Rule</th>
        <th>Complexity</th>
      </tr>
      <tr>
        <td><strong>Linear Attention</strong></td>
        <td>$S_t = S_{t-1} + v_t k_t^T$</td>
        <td>$O(d^2)$ per step</td>
      </tr>
      <tr>
        <td><strong>DeltaNet</strong></td>
        <td>$S_t = S_{t-1}(I - k_t k_t^T) + v_t k_t^T$</td>
        <td>$O(d^2)$ per step</td>
      </tr>
      <tr>
        <td><strong>RLS</strong></td>
        <td>$S_t = V_t^T K_t (K_t^T K_t)^{-1}$</td>
        <td>$O(td^2 + d^3)$</td>
      </tr>
    </table>

    <p>Recent work frames these as <strong>online regression</strong>: each model tries to minimize $\sum_{i=1}^{t} \|v_i - S_t k_i\|^2$. DeltaNet's advantage comes from the projection term $(I - k_t k_t^T)$, which removes outdated information before updating.</p>

    <p><strong>Our question:</strong> How do these models perform when the key-value relationship varies? Can DeltaNet handle nonlinear relationships like $v = k^4$ or $v = \sin(10\pi k)$?</p>

    <h2>II. Experimental Setup</h2>

    <h3>Configuration</h3>

    <p>Most experiments used 1000-token sequences with 64-dimensional keys, queries, and values—matching standard transformer configurations. For scaling analysis, we tested up to 32,000 tokens to evaluate long-context performance. All models operated in single-head mode to isolate the core mechanism behavior without multi-head complications.</p>

    <h3>Test Scenarios</h3>

    <p>We generated synthetic key-value pairs with controlled relationships:</p>
    <ul>
      <li><strong>Identity:</strong> $v = k$ (perfect linear)</li>
      <li><strong>Quadratic:</strong> $v = k \odot k$ (element-wise square)</li>
      <li><strong>Cubic:</strong> $v = k^3$ (higher-degree polynomial)</li>
      <li><strong>Quartic:</strong> $v = k^4$ (very high degree)</li>
      <li><strong>Exponential:</strong> $v = \exp(k)$ (unbounded growth)</li>
      <li><strong>Low-frequency sine:</strong> $v = \sin(\pi k)$</li>
      <li><strong>High-frequency sine:</strong> $v = \sin(10\pi k)$ (rapid oscillations)</li>
    </ul>

    <h3>A Note on Normalization</h3>

    <p>Before diving into results, it's important to clarify when normalization happens in practice. In real transformer architectures, the process looks like this: first, input embeddings are projected through learned weight matrices $W_q$, $W_k$, and $W_v$ to produce query, key, and value vectors. Then, normalization is applied to these projected vectors before the attention computation. This means normalization operates on $q = \text{norm}(xW_q)$ and similar for keys and values, not on the raw inputs.</p>

    <p>This detail matters because it means the nonlinearity we're testing (like $v = k^2$) happens conceptually before projection, and then normalization smooths the results afterward. We tested both scenarios: applying normalization after the nonlinearity (matching real architectures) and skipping it entirely to see the raw effect.</p>

    <h2>III. The Normalization Effect: Stability vs. Information</h2>

    <p>We first tested all relationships under standard normalized conditions—the way real transformer architectures operate. The results were strikingly uniform.</p>

    <div class="figure">
      <img src="../assets/linear-attn/normalized_vs_unnormalized.png" alt="Normalized vs unnormalized comparison">
      <div class="figure-caption"><strong>Figure 1:</strong> Side-by-side comparison. LEFT: With standard normalization, DeltaNet maintains consistent ~0.030 MSE across all relationships. RIGHT: Without normalization (log scale), we see wild variation—polynomials become easier while exponential/sine become harder.</div>
    </div>

    <p>With normalization enabled, DeltaNet achieves MSE between 0.028 and 0.030 across every relationship we tested—identity, quadratic, cubic, quartic, exponential, and high-frequency sine. No systematic degradation appears as mathematical nonlinearity increases. This was unexpected. Standard intuition suggests that $k^4$ or $e^k$ should challenge linear approximation more than simple identity, but the measurements show otherwise.</p>

    <p>The explanation lies in what normalization removes. By forcing all value vectors to unit length ($\|v\| = 1$), normalization strips away magnitude information and leaves only directional relationships. Whether values come from $k^2$ or $e^k$, after normalization they're all unit vectors positioned at various angles from the keys. The state matrix learns this angular mapping, which proves remarkably consistent across different generating functions.</p>

    <p>This uniformity has practical benefits for training stability—no single layer dominates numerically—but it also means we lose information about the original relationship structure. To understand what normalization hides, we needed to test without it.</p>

    <h2>IV. Removing Normalization: The Polynomial Paradox</h2>

    <p>Without normalization, the landscape changes completely:</p>

    <div class="figure">
      <img src="../assets/linear-attn/normalization_effect.png" alt="Normalization effect on DeltaNet">
      <div class="figure-caption"><strong>Figure 2:</strong> Ratio of unnormalized MSE to normalized MSE for DeltaNet. Values > 1 (red bars) indicate normalization helps; values < 1 (green) indicate raw relationship is easier. Polynomials paradoxically get easier without normalization.</div>
    </div>

    <table>
      <tr>
        <th>Relationship</th>
        <th>Normalized MSE</th>
        <th>Unnormalized MSE</th>
        <th>Ratio (unnorm/norm)</th>
      </tr>
      <tr>
        <td>Identity</td>
        <td>0.028</td>
        <td>0.026</td>
        <td>0.93×</td>
      </tr>
      <tr>
        <td>Quadratic</td>
        <td>0.030</td>
        <td>0.001</td>
        <td><strong style="color: var(--morandi-sage-dark)">0.03× (easier!)</strong></td>
      </tr>
      <tr>
        <td>Cubic</td>
        <td>0.030</td>
        <td>0.0001</td>
        <td><strong style="color: var(--morandi-sage-dark)">0.003× (much easier!)</strong></td>
      </tr>
      <tr>
        <td>Quartic</td>
        <td>0.030</td>
        <td>0.00001</td>
        <td><strong style="color: var(--morandi-sage-dark)">0.0003× (extremely easy!)</strong></td>
      </tr>
      <tr>
        <td>Exponential</td>
        <td>0.030</td>
        <td>1.92</td>
        <td><strong style="color: var(--renaissance-burgundy)">64× (much harder!)</strong></td>
      </tr>
      <tr>
        <td>Sin (10π)</td>
        <td>0.030</td>
        <td>0.96</td>
        <td><strong style="color: var(--renaissance-burgundy)">32× (harder)</strong></td>
      </tr>
    </table>

    <h3>The Polynomial Mystery: Why Easier Without Normalization?</h3>

    <p>The most surprising finding deserves deeper examination. Intuitively, we'd expect higher-degree polynomials to be harder for linear models—after all, $k^4$ is "more nonlinear" than $k^2$. Yet our measurements show the opposite: quadratic achieves 30× lower error than normalized, cubic 100×, and quartic 3000×. What's happening?</p>

    <p>The answer lies in magnitude shrinkage. When keys are normalized to unit vectors, most elements fall in the range $[-0.5, 0.5]$ due to the high-dimensional geometry. Squaring these values doesn't amplify them—it crushes them toward zero. Consider a key element $k_i = 0.5$. Raising it to successive powers produces $k^2 = 0.25$, $k^3 = 0.125$, $k^4 = 0.0625$. Each operation halves the magnitude.</p>

    <p>We measured this effect quantitatively across 1000 random normalized keys. Identity vectors have mean magnitude 1.0 and variance 0.0156. Quadratic drops to magnitude 0.21 (5× shrinkage) with variance 0.00046 (34× reduction). Cubic plummets further to magnitude 0.056 and variance 0.000051. By quartic, we're at magnitude 0.017 with variance 0.000005—the vectors are nearly constant!</p>

    <div class="figure">
      <img src="../assets/linear-attn/polynomial_regression_fit.png" alt="Polynomial regression visualization">
      <div class="figure-caption">Linear regression fits for different relationships. Dots show the true (nonlinear) relationship between keys and values. Red lines show DeltaNet's learned linear approximation—which must be straight lines since $S_t @ k$ is a linear function. For identity, the linear fit matches perfectly. For quadratic and cubic, the true relationships are curved (parabola and cubic curve), but because magnitude shrinkage compresses values near zero, a simple straight line approximates them remarkably well.</div>
    </div>

    <p>For linear regression, this is a dream scenario. The state matrix $S_t$ learns to map keys to values through a linear function $S_t @ k$. When the true relationship is identity, the linear fit is perfect. When values come from $k^2$ or $k^3$, we might expect poor linear approximation—after all, parabolas aren't lines. But magnitude shrinkage changes everything. With variance compressed to 0.00046 for quadratic and 0.000051 for cubic, the values cluster so tightly near zero that a nearly-flat straight line captures most of the signal. The mathematical nonlinearity remains, but the signal variance that regression must capture becomes trivial.</p>

    <p>Contrast this with exponential and sine functions. Exponentials cause magnitude explosion: even with clipping, $e^k$ creates large dynamic range with MSE jumping to 1.92. High-frequency sine ($\sin(10\pi k)$) oscillates rapidly across the input range, producing MSE of 0.96. These functions maintain or amplify variance, giving linear regression real difficulty. They're the only cases where nonlinearity translates to genuine hardness for the linear approximation.</p>

    <h2>V. Normalization as Architectural Choice</h2>

    <p>Stepping back, these experiments reveal normalization as a fundamental design decision rather than mere numerical convenience. The trade-off is clear: stability and consistency versus information preservation.</p>

    <p>With normalization, we get uniform behavior across diverse relationships. Whether the true mapping is $k \to k^2$ or $k \to e^k$, the normalized system sees only angular relationships between unit vectors. This consistency makes training stable—no single layer dominates numerically—and ensures predictable behavior across different data distributions. For attention mechanisms primarily routing information based on similarity rather than absolute magnitude, this directional focus often matches the desired behavior.</p>

    <p>Without normalization, we confront the raw characteristics of each relationship. Exponentials blow up to MSE above 1.9, creating large gradients during training. Polynomials collapse toward zero through magnitude shrinkage, potentially causing vanishing gradients elsewhere. This variation makes optimization treacherous—different layers would require dramatically different learning rates to converge simultaneously.</p>

    <p>The choice isn't about which is "better" in absolute terms, but rather what the architecture needs. Modern transformers universally adopt normalization precisely because the stability benefits outweigh the information loss for their use cases. Our measurements quantify both sides of this trade-off explicitly.</p>

    <h2>VI. Optimal Linear Approximation: DeltaNet vs RLS</h2>

    <p>Recursive Least Squares (RLS) represents the theoretical optimum for linear approximation—it explicitly maintains $(K^T K)^{-1}$ to compute the globally best linear fit at every step. This comes at $O(td^2 + d^3)$ computational cost compared to DeltaNet's $O(d^2)$. Does the extra computation pay off?</p>

    <table>
      <tr>
        <th>Relationship</th>
        <th>DeltaNet (normalized)</th>
        <th>RLS (normalized)</th>
        <th>Gap</th>
      </tr>
      <tr>
        <td>Identity</td>
        <td>0.028</td>
        <td>0.028</td>
        <td>1.00×</td>
      </tr>
      <tr>
        <td>Quadratic</td>
        <td>0.030</td>
        <td>0.029</td>
        <td>1.03×</td>
      </tr>
      <tr>
        <td>Cubic</td>
        <td>0.030</td>
        <td>0.029</td>
        <td>1.03×</td>
      </tr>
      <tr>
        <td>Exponential</td>
        <td>0.030</td>
        <td>0.029</td>
        <td>1.03×</td>
      </tr>
    </table>

    <p><strong>Finding:</strong> Under normalization, DeltaNet and RLS perform nearly identically (gap < 5%). The expensive $O(d^3)$ matrix inversion in RLS provides minimal benefit when values are normalized.</p>

    <p>This suggests DeltaNet's incremental update rule is sufficient for normalized settings—the global covariance correction of RLS doesn't help significantly.</p>

    <h2>VII. What We Didn't Find</h2>

    <p>We started this investigation expecting to identify fundamental limitations of DeltaNet when confronted with extreme nonlinearities. Surely quartic polynomials, exponentials, or high-frequency periodic functions would expose breaking points where the linear approximation fails catastrophically.</p>

    <p>Under standard normalized conditions, no such breaking points emerged. DeltaNet maintained MSE around 0.030 across every relationship tested—from simple identity through $k^4$ to $\sin(10\pi k)$. The anticipated "nonlinear ceiling" where performance would degrade sharply simply didn't materialize in realistic settings.</p>

    <p>This outcome isn't experimental failure but rather genuine insight into normalization's power. By projecting all relationships onto the unit sphere, normalization makes them equally tractable to linear approximation from a directional perspective. The wild diversity we observed without normalization—polynomials collapsing through magnitude shrinkage, exponentials exploding to MSE above 1.9—gets compressed into uniform angular variation that linear models handle consistently.</p>

    <p>For practitioners deploying these systems, this validates current architectural choices. DeltaNet with normalization robustly handles diverse key-value relationships without requiring special-casing or relationship-specific tuning. The RLS optimum provides minimal improvement (gap under 5%), suggesting the simpler and cheaper DeltaNet update suffices for normalized contexts.</p>

    <p>For researchers, the findings highlight how evaluation conditions matter. Testing under realistic normalization reveals robustness; testing without reveals relationship-specific phenomena like polynomial variance collapse. Both perspectives inform design, but confusing one for the other leads to misleading conclusions about fundamental limitations.</p>

    <h2>VIII. Multi-Query Retrieval Capacity</h2>

    <p>Forward-pass reconstruction measures one aspect of performance, but attention mechanisms must also support retrieval—querying the compressed state with historical keys to recover corresponding values. We tested whether this capacity holds when retrieving multiple pairs simultaneously.</p>

    <p>After processing 1000 tokens to build the final state $S_{\text{final}}$, we randomly selected past keys and measured reconstruction accuracy for their associated values. The test scaled from single-pair retrieval up to 50 simultaneous queries.</p>

    <div class="figure">
      <img src="../assets/linear-attn/retrieval_capacity.png" alt="Retrieval capacity">
      <div class="figure-caption"><strong>Figure 3:</strong> Retrieval MSE vs. number of retrieved pairs across three relationships. Identity (left) shows perfect recall—the state matrix learned exactly $S = I$ and can retrieve any historical pair flawlessly. Quadratic (middle) shows minimal degradation even retrieving 50 pairs. Exponential (right) struggles significantly, with error jumping from 0.004 for single retrieval to 2.9 for 10 pairs.</div>
    </div>

    <p>For identity relationships ($v = k$), both DeltaNet and RLS achieve remarkable results. Retrieval error stays below $10^{-6}$ regardless of how many pairs we ask for simultaneously. This makes sense—the optimal state matrix for identity is just $S^* = I$, and both methods converge to this exactly. The state becomes a perfect compressed representation.</p>

    <p>Quadratic relationships ($v = k^2$) show graceful degradation. DeltaNet maintains MSE around 0.001 whether retrieving 1 pair or 50, with RLS performing slightly better at 0.0007. The magnitude shrinkage discussed earlier helps here—when values cluster near zero, they're easier to store compressly in the state matrix.</p>

    <p>Exponential relationships reveal real capacity limits. Single-pair retrieval starts at MSE 0.004, but jumps to 2.9 when querying 10 historical pairs simultaneously. The state matrix can't maintain detailed information about each exponential value when they span such large magnitude ranges. RLS does better (MSE around 1.0) by accounting for key covariances explicitly, but still struggles compared to identity or polynomial cases.</p>

    <p>This retrieval degradation connects directly to the information-theoretic limits we'll explore later—when linear compression can't preserve relationship structure, multi-query retrieval suffers proportionally.</p>

    <h2>IX. Short Convolution as Nonlinearity Regulator</h2>

    <p>The exponential relationship's poor performance—both in reconstruction and retrieval—suggested exploring architectural modifications beyond the core attention mechanism. Short convolutions offer local context mixing that might help smooth problematic nonlinearities.</p>

    <p>We tested 1D convolution with kernel sizes 3, 5, and 7, applied to both keys and values before DeltaNet processing. The hypothesis: local averaging might tame magnitude explosions while preserving overall structure.</p>

    <div class="figure">
      <img src="../assets/linear-attn/short_conv_effect.png" alt="Short convolution effect">
      <div class="figure-caption"><strong>Figure 4:</strong> Effect of short convolution on DeltaNet (log scale). For exponential relationships, short conv dramatically reduces MSE from 1.92 to 0.03—a 64× improvement! Quadratic sees slight degradation, while identity improves modestly.</div>
    </div>

    <div class="insight-box">
      <h3>Key Finding: Short Conv Helps Extreme Nonlinearities</h3>
      <p><strong>Exponential relationships:</strong> Short conv provides massive benefit—MSE drops from 1.92 (no conv) to 0.033 (kernel=7). This 64× improvement suggests local smoothing helps tame magnitude explosions.</p>

      <p><strong>Polynomial relationships:</strong> Interestingly, short conv slightly hurts polynomials. Quadratic MSE increases from 0.001 to 0.034. This may be because convolution disrupts the element-wise structure.</p>

      <p><strong>Identity:</strong> Minor improvement (0.030 → 0.027), suggesting convolution adds useful inductive bias for general cases.</p>
    </div>

    <p>Short convolution acts as a <strong>nonlinearity regulator</strong>—smoothing extreme relationships while preserving structure for well-behaved ones.</p>

    <h2>X. Scaling Analysis: From 500 to 32,000 Tokens</h2>

    <p>Modern applications demand long-context processing—32k tokens or more. How do these mechanisms scale as sequence length grows?</p>

    <div class="figure">
      <img src="../assets/linear-attn/scaling_seqlen.png" alt="Scaling with sequence length">
      <div class="figure-caption"><strong>Figure 5:</strong> MSE vs. sequence length (log scale). Linear attention degrades catastrophically (exponential growth), while DeltaNet and RLS remain stable. For exponential relationships (right), all methods struggle but DeltaNet/RLS scale gracefully.</div>
    </div>

    <table>
      <tr>
        <th>Model</th>
        <th>500 tokens</th>
        <th>4000 tokens</th>
        <th>32000 tokens</th>
      </tr>
      <tr>
        <td><strong>Linear Attention</strong></td>
        <td>0.40</td>
        <td>20.8</td>
        <td>1306 (!)</td>
      </tr>
      <tr>
        <td><strong>DeltaNet</strong></td>
        <td>0.030</td>
        <td>0.031</td>
        <td>0.031</td>
      </tr>
      <tr>
        <td><strong>RLS</strong></td>
        <td>0.030</td>
        <td>0.031</td>
        <td>0.031</td>
      </tr>
    </table>

    <p>The divergence is stark. Vanilla linear attention starts reasonably at 500 tokens but degrades exponentially. By 4000 tokens, error has grown 52×. At 32,000 tokens, it completely breaks down with MSE exceeding 1300—the model has essentially lost all ability to reconstruct identity mappings. The fundamental assumption that keys remain approximately orthogonal ($K^T K \approx I$) simply doesn't hold as correlations accumulate over long sequences.</p>

    <p>DeltaNet and RLS tell a different story. Both maintain MSE around 0.031 regardless of sequence length. The delta rule's projection term $( I - k_t k_t^T)$ actively removes error accumulation before each update, preventing the drift that plagues vanilla attention. Even scaling from 4000 to 32,000 tokens—an 8× increase—changes nothing. The error stays flat.</p>

    <p>For exponential relationships, the pattern holds though absolute numbers are higher. DeltaNet reaches MSE 2.06 at 32k tokens while vanilla linear attention hits 1534. The gap between practical (DeltaNet) and broken (vanilla) widens at scale. This validates DeltaNet specifically for the long-context scenarios modern applications demand.</p>

    <h2>XI. Information-Theoretic Analysis</h2>

    <p>Linear attention compresses a growing history $K_t, V_t$ (size $2td$) into a fixed state $S_t$ (size $d^2$). What information is lost?</p>

    <h3>Compression Rate</h3>

    <p>For our setup (t=1000, d=64):</p>
    <ul>
      <li>Original: $2 \times 1000 \times 64 = 128{,}000$ scalars</li>
      <li>Compressed: $64 \times 64 = 4{,}096$ scalars</li>
      <li><strong>Compression ratio: 3.2%</strong> (96.8% reduction)</li>
    </ul>

    <p>This massive compression necessarily loses information. We quantify this using <strong>mutual information</strong>.</p>

    <h3>Information Retention: MI(S@K, V) / MI(K, V)</h3>

    <p>We compute mutual information between keys and values, then measure how much is preserved after compression through the state matrix.</p>

    <div class="figure">
      <img src="../assets/linear-attn/information_theory.png" alt="Information theory metrics">
      <div class="figure-caption"><strong>Figure 6:</strong> LEFT: Information retention (%). DeltaNet retains 99.6% of information for identity but only 1.2% for exponential—explaining the MSE difference. RIGHT: Scatter plot shows strong correlation between info retention and MSE.</div>
    </div>

    <table>
      <tr>
        <th>Relationship</th>
        <th>MI(K,V)</th>
        <th>DeltaNet Retention</th>
        <th>RLS Retention</th>
      </tr>
      <tr>
        <td>Identity</td>
        <td>3.25 bits</td>
        <td><strong>99.6%</strong></td>
        <td>100%</td>
      </tr>
      <tr>
        <td>Quadratic</td>
        <td>1.62 bits</td>
        <td>0.8%</td>
        <td>2.0%</td>
      </tr>
      <tr>
        <td>Exponential</td>
        <td>2.87 bits</td>
        <td><strong>1.2%</strong></td>
        <td>5.8%</td>
      </tr>
      <tr>
        <td>Sin (10π)</td>
        <td>1.62 bits</td>
        <td>1.2%</td>
        <td>3.1%</td>
      </tr>
    </table>

    <div class="insight-box">
      <h3>Key Finding: Information Loss Explains MSE</h3>
      <p><strong>Identity achieves near-perfect retention:</strong> DeltaNet preserves 99.6% of the 3.25 bits of mutual information between keys and values. This explains the near-zero MSE.</p>

      <p><strong>Nonlinear relationships suffer massive loss:</strong> For exponential, DeltaNet retains only 1.2% (0.035 bits out of 2.87). The state matrix cannot linearly compress the exponential relationship.</p>

      <p><strong>RLS helps but doesn't solve it:</strong> Even with optimal linear approximation, RLS retains only 5.8% for exponential. The fundamental issue is linearity, not the update rule.</p>

      <p><strong>Paradoxically, low MI ≠ easy:</strong> Quartic has lowest original MI (0.45 bits) and lowest MSE (0.00001), but retention is still poor (1.7%). This reveals that polynomial shrinkage creates <em>low-information</em> relationships that are coincidentally easy to approximate.</p>
    </div>

    <p>Information theory provides a principled framework for understanding linear attention's limits: <strong>compression is lossy, and loss severity depends on relationship structure.</strong></p>

    <h2>XII. Conclusion</h2>

    <p>Testing linear attention mechanisms across diverse key-value relationships revealed patterns that weren't obvious from theory alone. Normalization emerged not as a numerical convenience but as fundamentally reshaping what these models learn. By converting all vectors to unit length, we shift from tracking magnitude and direction to purely angular relationships. This trade-off brings remarkable stability—DeltaNet maintains consistent performance whether values come from $k^2$ or $e^k$—but at the cost of losing information about scale.</p>

    <p>The polynomial mystery taught us to look beyond mathematical nonlinearity to actual signal characteristics. Higher-degree polynomials paradoxically become easier because they shrink variance toward zero. When quartic values cluster with variance 0.000005, almost any linear function fits well. This isn't a failure of testing but a genuine insight: "difficulty" for linear models depends on variance and dynamic range, not polynomial degree.</p>

    <p>Scaling tests extending to 32,000 tokens exposed the fundamental instability of vanilla linear attention. The assumption that keys stay approximately orthogonal breaks down catastrophically—MSE exploding from 0.4 to 1306 as correlations accumulate. DeltaNet's delta rule projection fixes this by explicitly removing error before each update. The result is flat scaling: 0.031 MSE whether processing 500 or 32,000 tokens.</p>

    <p>Information-theoretic analysis provided the clearest framework for understanding capacity limits. Linear attention compresses growing history into fixed-size state (3.2% compression ratio for our setup). DeltaNet retains 99.6% of mutual information for identity relationships—nearly perfect compression. For exponentials, only 1.2% survives. This quantifies an intuitive truth: linear models can't losslessly compress nonlinear relationships, and some relationships resist compression far more than others.</p>

    <p>Retrieval testing showed these limits in action. Identity mappings enable perfect multi-query retrieval—the state matrix learns exactly $S = I$ and can reconstruct any historical pair flawlessly. Exponential relationships degrade sharply: single-pair retrieval succeeds reasonably (MSE 0.004) but querying 10 pairs simultaneously jumps to MSE 2.9. The compressed state can't maintain detailed information when values span huge magnitude ranges.</p>

    <p>Short convolution provided an unexpected path forward for specific failure cases. Adding kernel-size-7 convolution to exponential relationships reduced MSE 64-fold (1.92 → 0.03), essentially solving a problem that looked fundamental. Local smoothing helps tame magnitude explosions. Interestingly, the same convolution slightly hurt polynomials, suggesting the solution is relationship-specific rather than universally beneficial.</p>

    <p>For practitioners deploying these systems, the lessons are clear. Normalization isn't optional—it provides the stability that makes diverse data tractable. DeltaNet's delta rule offers genuine advantages over vanilla linear attention, especially at longer contexts. Information-theoretic metrics like mutual information retention give principled ways to evaluate beyond simple MSE. And relationship structure matters: identity and polynomial cases work well, exponentials challenge the fundamental linear assumption.</p>

    <p>For researchers, the work highlights gaps between mathematical and practical difficulty. Testing under realistic conditions (normalization, appropriate sequence lengths) matters more than theoretical worst-case analysis. The polynomial shrinkage phenomenon suggests looking at signal characteristics—variance, dynamic range, correlation structure—rather than just functional form. And the compression-information trade-off presents optimization targets: can we do better than 1.2% retention for exponentials while maintaining DeltaNet's efficiency?</p>

    <p>The core limitation remains: linear models approximating nonlinear relationships face bounded capacity. But within those bounds, proper configuration (normalization, delta rule projection, optional convolution) extends capability substantially. Understanding exactly where and why these limits apply guides both deployment decisions and future architectural innovation.</p>

    <div class="back-link">
      <a href="../index.html">← Back to Home</a>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        throwOnError: false
      });
    });
  </script>
</body>
</html>
